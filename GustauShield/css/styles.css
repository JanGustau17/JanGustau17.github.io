/* Basic Glitch Container for Text */
    .glitch {
      position: relative; /* Needed for absolute positioning of pseudo-elements */
      color: #00ffff; /* Example color, or use Tailwind text classes */
      /* Optional: Add data-text attribute in HTML equal to the text content */
    }

    .glitch::before,
    .glitch::after {
      content: attr(data-text); /* Duplicate text content from data-text attribute */
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a1a; /* Match your body background */
      overflow: hidden;
      color: #00ffff; /* Match text color */
    }

    /* First Glitch Layer (Magenta Shift) */
    .glitch::before {
      left: 2px;
      text-shadow: -1px 0 #ff00ff; /* Magenta */
      clip-path: inset(20% 0 55% 0); /* Initial slice */
      animation: glitch-anim-1 2s infinite linear alternate-reverse;
    }

    /* Second Glitch Layer (Green/Blue Shift) */
    .glitch::after {
      left: -2px;
      text-shadow: -1px 0 #00ff00, 1px 1px #0077ff; /* Green & Blue */
      clip-path: inset(65% 0 10% 0); /* Initial slice */
      animation: glitch-anim-2 1.5s infinite linear alternate-reverse;
    }

    /* Animation Keyframes (Random slicing) */
    @keyframes glitch-anim-1 {
      0% { clip-path: inset(20% 0 55% 0); transform: translate(0, 0); }
      20% { clip-path: inset(80% 0 5% 0); transform: translate(-3px, 1px); }
      40% { clip-path: inset(35% 0 40% 0); transform: translate(2px, -1px); }
      60% { clip-path: inset(10% 0 85% 0); transform: translate(-1px, 2px); }
      80% { clip-path: inset(55% 0 20% 0); transform: translate(3px, -2px); }
      100% { clip-path: inset(30% 0 60% 0); transform: translate(0, 0); }
    }

    @keyframes glitch-anim-2 {
      0% { clip-path: inset(65% 0 10% 0); transform: translate(0, 0); }
      25% { clip-path: inset(15% 0 70% 0); transform: translate(1px, -1px); }
      50% { clip-path: inset(45% 0 45% 0); transform: translate(-2px, 2px); }
      75% { clip-path: inset(90% 0 2% 0); transform: translate(2px, 1px); }
      100% { clip-path: inset(25% 0 50% 0); transform: translate(-1px, 0); }
    }


    /* --- Glitch Effect for Images (Requires Wrapper) --- */
    .glitch-image-wrapper {
        position: relative;
        display: inline-block; /* Or block, depending on layout */
        overflow: hidden; /* Important to contain pseudo-elements */
        vertical-align: middle; /* Helps alignment if inline-block */
        background: #0a0a1a; /* Match background */
    }

    /* Hide original image if using pseudo-elements for full effect */
    /* .glitch-image-wrapper img { opacity: 0; } */ /* Use only if ::before/::after fully recreate image */

    .glitch-image-wrapper::before,
    .glitch-image-wrapper::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* Use the same image as the background for pseudo-elements */
      background: var(--glitch-image-url) center center / cover no-repeat;
      /* --glitch-image-url needs to be set inline style on the wrapper! */
    }

    /* Apply animations and clipping like the text version */
    .glitch-image-wrapper::before {
      left: 3px;
      animation: glitch-anim-1 2s infinite linear alternate-reverse 0.1s; /* Add delay */
      /* You might need mix-blend-mode or colored overlays instead of text-shadow */
      /* background-color: rgba(255, 0, 255, 0.3); */
      /* mix-blend-mode: screen; */
    }

    .glitch-image-wrapper::after {
      left: -3px;
      animation: glitch-anim-2 1.5s infinite linear alternate-reverse 0.2s; /* Add delay */
      /* background-color: rgba(0, 255, 0, 0.3); */
      /* mix-blend-mode: screen; */
    }


    /* Make sure this is in your css/styles.css or your main <style> block */
.glitch-cipher-jp {
  position: relative;
  display: inline-block;
  color: #00fff7; /* Base color for the main text */
  font-family: 'Orbitron', monospace; /* Ensure Orbitron is loaded if not globally set */
  font-weight: bold;
  font-size: 1.5rem; /* Or adjust as needed */
  letter-spacing: 0.05em;
  isolation: isolate; /* For stacking context with z-index on pseudo-elements */
}

/* This ::before will create the first layer of the text glitch */
.glitch-cipher-jp::before {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  overflow: hidden;
  color: #ff00ff; /* Magenta, for example */
  opacity: 0.4;   /* Make it semi-transparent */
  z-index: -1;    /* Behind the main text */
  animation: glitch-lines 2s infinite linear alternate-reverse;
}

/* This ::after rule will be used for the Katakana flicker.
   The CSS rule for ::after that might have duplicated attr(data-text) 
   is overridden by this more specific Katakana one if it's defined later
   or has higher specificity (which is not the case here, but the last one defined wins).
   Effectively, you'll have one text glitch layer (::before) and one Katakana layer (::after).
*/
.glitch-cipher-jp::after {
  content: 'カ ズ ナ ツ ロ キ'; /* Katakana random sample */
  position: absolute;
  top: -10px; /* Position above the main text */
  left: 0;
  width: 100%; /* Ensure it spans the width of the main text for alignment */
  text-align: center; /* Center the Katakana over the text */
  font-size: 0.75rem;
  color: #00ffff; /* Cyan, or another color for the Katakana */
  letter-spacing: 0.2em;
  opacity: 0.2;
  filter: blur(1px);
  animation: jp-flicker 4s infinite alternate;
  z-index: -1; /* Could also be -1 or 1 depending on desired layering */
}


/* Note on the original CSS:
  You had two definitions for .glitch-cipher-jp::after. 
  The browser will only use the properties from the *last* one it encounters for ::after,
  or a combination if properties aren't overridden.
  For `content`, the Katakana will win. 
  For `animation`, `jp-flicker` will win for `::after`.
  The `glitch-lines` animation will still apply to `::before`.
*/

/* Your keyframes */
@keyframes glitch-lines {
  0% { clip: rect(0, 9999px, 0, 0); transform: translate(0, 0); }
  10% { clip: rect(5px, 9999px, 20px, 0); transform: translate(-2px, -1px) rotate(0.3deg); }
  20% { clip: rect(10px, 9999px, 15px, 0); transform: translate(2px, 1px) rotate(-0.3deg); }
  40% { clip: rect(4px, 9999px, 25px, 0); transform: translate(1px, -2px); }
  /* Ensure the last step of clip makes sense or remove if it should always be partially clipped */
  100% { clip: rect(15px, 9999px, 30px, 0); transform: none; } /* Example: Keep some clipping */
}

@keyframes jp-flicker {
  0%, 100% { opacity: 0.05; transform: translateY(0px); }
  50% { opacity: 0.2; transform: translateY(3px); }
}
